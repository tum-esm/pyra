---
hide_table_of_contents: true
---

<!-- markdownlint-disable -->

# <kbd>module</kbd> `core.utils.helios_image_processing`






---

## <kbd>class</kbd> `HeliosImageProcessing`
Class for processing images from the Helios camera. 

See https://pyra.esm.ei.tum.de/docs/user-guide/tum-plc-and-helios#what-does-helios-do for more information on Helios. 




---

### <kbd>method</kbd> `add_markings_to_image`

```python
add_markings_to_image(
    img: ndarray[Any, Any],
    edge_fraction: float,
    circle_cx: int,
    circle_cy: int,
    circle_r: int
) → ndarray[Any, Any]
```

Put text for edge fraction and mark circles in image. 

---

### <kbd>method</kbd> `add_text_to_image`

```python
add_text_to_image(
    img: ndarray[Any, Any],
    text: str,
    color: tuple[int, int, int] = (200, 0, 0),
    position: Literal['top-left', 'bottom-left'] = 'bottom-left'
) → ndarray[Any, Any]
```

Put some text on the bottom left of an image 

---

### <kbd>method</kbd> `get_edge_fraction`

```python
get_edge_fraction(
    frame: ndarray[Any, Any],
    station_id: str,
    edge_color_threshold: int,
    save_images_to_archive: bool = False,
    save_current_image: bool = False
) → float
```

For a given frame determine the number of "edge pixels" with respect to the inner 90% of the lense diameter and the "status". The status is 1 when the edge pixels are above the given threshold and 0 otherwise. 

1. Downscale image (faster processing) 2. Convert to grayscale image 3. Determine position and size of circular opening 4. Determine edges in image (canny edge filter) 5. Only consider edges inside 0.9 * circleradius 

Returns the "edge pixel fraction". 


