---
hide_table_of_contents: true
---

<!-- markdownlint-disable -->

# <kbd>module</kbd> `core.interfaces.plc_interface`






---

## <kbd>class</kbd> `PLCInterface`
Uses the snap7 library to connect to the Siemens PLC operating the enclosure hardware. 

Manual: https://buildmedia.readthedocs.org/media/pdf/python-snap7/latest/python-snap7.pdf 

### <kbd>method</kbd> `__init__`

```python
__init__(plc_version: Literal[1, 2], plc_ip: StrictIPAdress) → None
```








---

### <kbd>method</kbd> `connect`

```python
connect() → None
```

Connects to the PLC Snap7. Times out after 30 seconds. 

---

### <kbd>method</kbd> `cover_is_closed`

```python
cover_is_closed() → bool
```

Reads the single value "state.cover_closed"  

---

### <kbd>method</kbd> `disconnect`

```python
disconnect() → None
```

Disconnects from the PLC Snap7 

---

### <kbd>method</kbd> `get_cover_angle`

```python
get_cover_angle() → int
```

Reads the single value "actors.current_angle"  

---

### <kbd>method</kbd> `is_responsive`

```python
is_responsive() → bool
```

Pings the PLC 

---

### <kbd>method</kbd> `rain_is_detected`

```python
rain_is_detected() → bool
```

Reads the single value "state.rain"  

---

### <kbd>method</kbd> `read`

```python
read() → PLCState
```

Read the whole state of the PLC 

---

### <kbd>method</kbd> `reset`

```python
reset() → None
```

Does not check, whether the value has been changed 

---

### <kbd>method</kbd> `reset_is_needed`

```python
reset_is_needed() → bool
```

Reads the single value "state.reset_needed"  

---

### <kbd>method</kbd> `set_auto_temperature`

```python
set_auto_temperature(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `set_cover_angle`

```python
set_cover_angle(value: int) → None
```

Does not check, whether the value has been changed 

---

### <kbd>method</kbd> `set_manual_control`

```python
set_manual_control(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `set_manual_temperature`

```python
set_manual_temperature(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `set_power_camera`

```python
set_power_camera(new_state: bool) → None
```

Raises `PLCInterface.PLCError`, if value hasn't been changed 

---

### <kbd>method</kbd> `set_power_computer`

```python
set_power_computer(new_state: bool) → None
```

Raises `PLCInterface.PLCError`, if value hasn't been changed 

---

### <kbd>method</kbd> `set_power_heater`

```python
set_power_heater(new_state: bool) → None
```

Raises `PLCInterface.PLCError`, if value hasn't been changed 

---

### <kbd>method</kbd> `set_power_router`

```python
set_power_router(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `set_power_spectrometer`

```python
set_power_spectrometer(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `set_sync_to_tracker`

```python
set_sync_to_tracker(new_state: bool) → None
```

Raises PLCInterface.PLCError, if value hasn't been changed 

---

### <kbd>method</kbd> `update_config`

```python
update_config(new_plc_version: Literal[1, 2], new_plc_ip: StrictIPAdress) → None
```

Update the internally used config (executed at the) beginning of enclosure-control's run-function. 

Reconnecting to PLC, when IP has changed. 


